/* -----------------------------------------------------------------------------
  Filename:    appdesc.c
  Description: Implementation example for the proper usage with CANdesc.
                
                Manufacturer: SYMC
                EcuDocFile:   D:\07_Working\E100\source\Geny\Cdd\SYMC_E100_LDC_UDS.cdd
                Variant:      CommonDiagnostics

  Generated by CANdelaGen, Tue Apr 07 11:07:55 2020
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2013 by Vector Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vector Informatik 
  GmbH.
  
  Vector Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vector Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ History
 ----------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------------
  Please note, that the demo and example programs only show special aspects of 
  the software. With regard to the fact that these programs are meant for 
  demonstration purposes only, Vector Informatik's liability shall be expressly 
  excluded in cases of ordinary negligence, to the extent admissible by law or 
  statute.
  ---------------------------------------------------------------------------- */

/* 
------------------------------------------------------------------------------------------------------------------------
                                             A U T H O R   I D E N T I T Y                                              
------------------------------------------------------------------------------------------------------------------------
Initials   Name                  Company                                                                                
---------- --------------------- ---------------------------------------------------------------------------------------
Wse        Wilfried Steudle      Vector Informatik GmbH                                                                 
------------------------------------------------------------------------------------------------------------------------
                                            R E V I S I O N   H I S T O R Y                                             
------------------------------------------------------------------------------------------------------------------------
Date       Version  Author Modification type Issue Id      Affects                        Description                    
---------- -------- ------ ----------------- ------------- ------------------------------ -------------------------------
2016-10-05  6.25.00
                    Wse    Added             ESCAN00092153 SYMC(UDS:2012)                 Support SYMC UDS2012           
                    Wse    Fixed             ESCAN00092159 UDS:2012                       Compiler error: identifier Possibility of undefined parameter securitySeedObjIndex is undefined
                    Wse    Fixed             ESCAN00091636 UDS:2012                       Compiler warning: inconsistent storage class specification for Desc85Process
                    Wse    Fixed             ESCAN00092078 UDS:2012                       Pointer out of bounds in Desc85Process
2016-12-20  6.26.00
                    Wse    Fixed             ESCAN00093091 UDS:2012                       Check combination of attempt counter and attempt delay for all security levels in UDS2012
                    Wse    Fixed             ESCAN00055957 All                            appdesc.c missing line feed (LF) after carriage return (CR) on some lines
                    Wse    Fixed             ESCAN00092436 All                            Compiler error: (Linker Error) Symbol DescPostRoutineControlByIdentifier is undefined
                    Wse    Fixed             ESCAN00093238 All                            Null pointer read-access for busy-repeat-request (NRC 0x21) response in case of parallel client requests
2017-03-06  6.27.00
                    Wse    Fixed             ESCAN00093265 All                            Unexpected NRC 0x21 (BusyRepeatRequest) response sent to tester
2017-05-02  6.28.00
                    Wse    Fixed             ESCAN00094512 UDS:2012                       Compiler Warning: securitySeedObjIndex was declared but never referenced
                    Wse    Fixed             ESCAN00080010 UDS:2012                       Compiler error: DescInterruptDisable/DescInterruptRestore is not an expression
                    Wse    Fixed             ESCAN00095088 UDS:2012                       service $22 rejected for supported DID in case of unified PID handling
                    Wse    Fixed             ESCAN00081861 All                            Compiler warning: Truncating assignment in DescContextStateTask
                    Wse    Fixed             ESCAN00081853 All                            Compiler warning: Truncating assignment in DescPidDispatcher
                    Wse    Fixed             ESCAN00081852 All                            Compiler warning: Truncating assignment in DescUudtNetCANTxReserveResource
                    Wse    Fixed             ESCAN00081850 All                            Compiler warning: Truncating assignment in DescICNGetResponseData
                    Wse    Fixed             ESCAN00081836 All                            Compiler warning: Truncating assignment in DescConfirmation
                    Wse    Fixed             ESCAN00055156 All                            Compiler warning: truncating assignment
                    Wse    Fixed             ESCAN00081827 All                            Compiler warning: Truncating assignment in DescUsdtNetIsoTpCopyToCan
2017-07-24  6.28.01
                    Wse    Fixed             ESCAN00095783 UDS:2012                       CANdesc: array access out of bounds in function DescUudtNetCANCancelAllResponses()
2017-10-18  6.29.00
                    Wse    Added             ESCAN00097004 UDS:2012                       DescSetNegResponse can be called in ApplDescSecurityAccessGetSeed and ApplDescSecurityAccessCheckKey
2018-03-21  6.30.00
                    Wse    Added             ESCAN00098478 SYMC(UDS:2012)                 Specific shaper script for Symc:2012
                    Wse    Fixed             ESCAN00097832 All                            Response for service $22 incomplete in case of ring buffer used and multiple DIDs in request
                    Wse    Fixed             ESCAN00097834 All                            Handling of Gaps in a DID is not correct
                    Wse    Fixed             ESCAN00097915 All                            Response for service $22 incomplete if requested DID is handled as signal handler
                    Wse    Fixed             ESCAN00098423 All                            Response for service $22 incomplete in case of multiple DIDs in request using ring buffer mechanisms
                    Wse    Added             ESCAN00097837 All                            Variable handling of buffer size to support CAN-FD
2018-06-06  6.31.00
                    Wse    Fixed             ESCAN00099512 All                            NRC=0x78 is sent forever after request $19 04, $19 06 or $19 10
                    Wse    Added             ESCAN00098571 All                            Spontaneous messages in CAN-FD 
------------------------------------------------------------------------------------------------------------------------
 */


/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* Physical layer specific API */
#include "v_inc.h"
/* Check if CCL is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCL)
# include "ccl_cfg.h"
#endif

/* Check if CCLcom is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCLCOM)
# include "cclcom_cfg.h"
#endif

/* Make all CANdesc specific typedefs available */
#include "desc.h"
/* Include the implementation prototypes for prototype checks */
#include "appdesc.h"

/* Required for the implementation of ApplDescInitPosResFblBusInfo */
#include "tpmc.h"

#include "fbl_inc.h"
#include "Asw_EEPROM.h"
#include "Asw_DiagCan.h"

/* -----------------------------------------------------------------------------
    &&&~ Preprocessor constants (defines)
 ----------------------------------------------------------------------------- */

#define kDescEcuCryptoKey                                            0x12345678



/* -----------------------------------------------------------------------------
    &&&~ Function prototypes
 ----------------------------------------------------------------------------- */

static vuint32 SecM_ComputeKey(void);
static void SecM_Serializer(DescMsg tgtPtr, vuint32 data);



/* -----------------------------------------------------------------------------
    &&&~ RAM definitions
 ----------------------------------------------------------------------------- */

/* 64Bit seed stored for the later key compare */
static vuint32 g_applDescSeedX;
static vuint32 g_applDescSeedY;



/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# if defined (CCL_ENABLE_ERROR_HOOK) || defined (CCLCOM_ENABLE_ERROR_HOOK)
/* CCL takes care about this function */
# else
/* ********************************************************************************
 * Function name:ApplDescFatalError
 * Description: This function will be called each time while the debug mode is active a
 * CANdesc fault has been detected. If you reach this function it makes no sence to continue the tests since CANdesc
 * will not operate properly until next start of the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - errorCode:
 *       - The assert code text equivalent can be found in desc.h (kDescAssert....).
 *       - Access type: read
 *   - lineNumber:
 *       - Since the same fault could be cales on many places the line number shows where exactly it occured.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Set a break point at this place to know during the ECU development if you ran onto it.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescFatalError(vuint8 errorCode, vuint16 lineNumber)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(errorCode);
  DESC_IGNORE_UNREF_PARAM(lineNumber);

  /* When fatal error occurs, cause an ECU hang up at this point.
   * Please set break point at this line to investigate both parameter values. */
  for(;;);
}
# endif
#endif

#if defined (DESC_ENABLE_SPONTANEOUS_RES)
void DESC_API_CALLBACK_TYPE ApplDescSpontaneousResponseConfirmation(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
    /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  /* Check the transmission status */
  if(status == kDescOk)
  {
    /* "Spontaneous Response" was just successfully sent.
     */
  }
  else
  {
    /* There was some transmission error and the tester didn't received the "Spontaneous Response" response.
     */
  }
}
#endif

/*******************************************************************************
* NAME:              ApplDescInitPosResFblBusInfo
*
* CALLED BY:         CANdesc
* PRECONDITIONS:
*
* DESCRIPTION:       Initializes the busInfo with the concrete response address information
*                    (e.g. sourceAddr,TargetAddr, COM channel, etc.).
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE ApplDescInitPosResFblBusInfo(t_descUsdtNetBus* pBusInfo)
{
  /* Init the bus-info structure as shown below */
  pBusInfo->busType = kDescUsdtNetBusTypeIsoTp;/* on other bus systems use the apropriate bus-type */
  /*On multi channel systems */
  pBusInfo->comChannel = 0; /* set the CAN (FlexRay or other) channel on which to send */
  /* If the addressing scheme uses source/target addresses put here the tester addres to respond to */
  pBusInfo->testerId = 0xF1; /* set the CAN (FlexRay or other) channel on which to send */

#if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  /* If dynamic length is used, please use the correct buffer size of the corresponding DANIS driver!!! */
  pBusInfo->availBufferLength = kDescPrimBufferLen;
#endif

#if defined(TP_ENABLE_DYNAMIC_CHANNELS) && defined(TP_ENABLE_CANFD)
  /* If response shall be set as CAN-FD message please modify the value */
  pBusInfo->canType = kTpCAN20;
#endif

#if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) && \
    (defined(TP_ENABLE_MIXED_11_ADDRESSING) || \
    defined(TP_ENABLE_NORMAL_ADDRESSING)) )
  /* ********** for these use cases additional TPMC initalization is required ********** */
  {
    vuint8 tpChannel = kTpTxChannelCount;
    while (tpChannel != 0)
    {
      tpChannel--;
      if (kDescDiagConnection == TpTxGetConnectionNumber(tpChannel))
      {
# if defined(TP_ENABLE_MULTIPLE_ADDRESSING)
        tpTxInfoStruct[tpChannel].assignedDestination = kTpRequestDiagPhysical;
        tpTxInfoStruct[tpChannel].addressingFormat = kTpNormalAddressing; /*... respectively: kTpMixed11Addressing, kTpExtendedAddressing*/
# endif

# error "Replace the <DIAG_NORMAL_ADD_RES_ID> and <DIAG_NORMAL_ADD_REQ_ID> below with the real CANids and uncomment the line!"
        /* TpTxSetChannelID(tpChannel, <DIAG_NORMAL_ADD_RES_ID>, <DIAG_NORMAL_ADD_REQ_ID>); */
# if (kTpNumberOfCanChannels > 1)
        TpTxSetCanChannel(tpChannel, pBusInfo->comChannel);
# endif
        break;
      }
    }
  }
#endif
  return kDescOk;
}

/*  ********************************************************************************
 * Function name:ApplDescOnTransitionSession
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionSession(DescStateGroup newState, DescStateGroup formerState)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
   /* This is only a notification function. Using the "formerState" and the "newState" 
   * parameter you can distinguish the different transitions for this state group.
   */
  /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
;
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionSecurityAccess
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionSecurityAccess(DescStateGroup newState, DescStateGroup formerState)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
   /* This is only a notification function. Using the "formerState" and the "newState" 
   * parameter you can distinguish the different transitions for this state group.
   */
  /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
;
}


/*  ********************************************************************************
 * Function name:ApplDescEcuResetHard (Service request header:$11 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescEcuResetHard(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Contains no response data */
  if( pMsgContext->reqDataLen <= 0x01U )
	{
		pMsgContext->resData[ 0 ] = 0x01U;
		pMsgContext->resData = 1U;
		u8g_ReqReset = 1U;
	}
	else
	{
		DescSetNegResponse ( kDescNrcInvalidFormat);
	}
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescClearDiagInfo (Service request header:$14 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request byte after the Sid.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response after the Sid.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the service request length, excluding Sid byte only.
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the total service response length, excluding the Sid only.
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescClearDiagInfo(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Contains no response data */
  uint8_t u8_i;

	if( pMsgContext->reqDataLen <= 0x03U )
	{
		if ( ( pMsgContext->reqData[ 0 ] == 0xFFU )
			&& ( pMsgContext->reqData[ 1 ] == 0xFFU )
			&& ( pMsgContext->reqData[ 2 ] == 0xFFU ) )
		{
			/* Store new DTC in buffer */
			for ( u8_i = 0U; u8_i< 8U; u8_i++ )
			{
				DTC_BUFFER[ u8_i ] = 0U;
			}
			Eeprom_Write();
			pMsgContext->resDataLen = 0U;
		}
		else
		{
			DescSetNegResponse ( kDescNrcRequestOutOfRange );
		}
	}
	else
	{
		DescSetNegResponse ( kDescNrcInvalidFormat );
	}
	/* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDtcRNODTCBSM (Service request header:$19 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDtcRNODTCBSM(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
	uint8_t u8_i = 0U;
	uint16_t dtc_count = 0U;
	uint8_t u8_DTCStatusMask = 0U;
	uint8_t uds_u8Eeprom_ReadDTCDataByIdentifier[ 32 ];

	for( u8_i = 0U; u8_i< 8U; u8_i++ )
	{
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 0U ] = ( uint8_t )( DTC_BUFFER[ u8_i ] & 0x000000FFU );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 1U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0x0000FF00U ) >> 8U );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 2U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0x00FF0000U ) >> 16U );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 3U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0xFF000000U ) >> 24U );
	}
	u8_DTCStatusMask = pMsgContext->reqData[ 0 ];

	if( pMsgContext->reqDataLen <= 0x02U )
	{
		if( ( ( pMsgContext->reqData[ 0 ] & 0x9U ) >= 0x01 ) && ( ( pMsgContext->reqData[ 0 ] & 0x9U ) <= 0x09 ) ) /* DTC Status  Mask*/
		{
			for( u8_i = 0U; u8_i < DTC_CODE_NUMBER; u8_i++ )
			{
				if( ( uds_u8Eeprom_ReadDTCDataByIdentifier[u8_i] & u8_DTCStatusMask ) != 0x00U )
				{
					dtc_count++;
				}
			}

			pMsgContext->resData[ 0 ] = 0x09U; /* DTC Status Availability Mask*/
			pMsgContext->resData[ 1 ] = 0x00U;
			pMsgContext->resData[ 2 ] = ( uint8_t )( ( dtc_count & 0xFF00U ) >> 8U ); /* DTC_COUNT HIGHBYTE */
			pMsgContext->resData[ 3 ] = ( uint8_t )( dtc_count & 0x00FFU ); /* DTC_COUNT LOWBYTE */

			pMsgContext->resDataLen = 4U;
		}
		else
		{
			DescSetNegResponse ( kDescNrcRequestOutOfRange );
		}
	}
	else
	{
		DescSetNegResponse ( kDescNrcInvalidFormat );
	}
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDtcRDTCBSM (Service request header:$19 $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDtcRDTCBSM(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Dummy example how to access the request data. */
  /* Assumming the FIRST DATA byte contains important data which has to be less than a constant value. */
	uint8_t u8_i = 0U;
	uint16_t dtc_count = 0U;
	uint8_t u8_DTCStatusMask = 0U;
	uint8_t uds_u8Eeprom_ReadDTCDataByIdentifier[ 32 ];

	for( u8_i = 0U; u8_i< 8U; u8_i++ )
	{
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 0U ] = ( uint8_t )( DTC_BUFFER[ u8_i ] & 0x000000FFU );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 1U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0x0000FF00U ) >> 8U );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 2U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0x00FF0000U ) >> 16U );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 3U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0xFF000000U ) >> 24U );
	}

	u8_DTCStatusMask = pMsgContext->reqData[ 0 ];

	if( pMsgContext->reqDataLen <= 0x02U )
	{
		if( ( ( pMsgContext->reqData[ 0 ] & 0x9U ) >= 0x01 ) && ( ( pMsgContext->reqData[ 0 ] & 0x9U ) <= 0x09 ) ) /* DTC Status  Mask*/
		{
			pMsgContext->resData[ 0 ] = 0x09U; /* DTC Status Availability Mask*/

			for( u8_i = 0U; u8_i < DTC_CODE_NUMBER; u8_i++ )
			{
				if( ( uds_u8Eeprom_ReadDTCDataByIdentifier[u8_i] & u8_DTCStatusMask ) != 0x00U )
				{
					pMsgContext->resData[ ( dtc_count * 4U ) + 1U ] = DTC_CODE_Array[ 0 ][ u8_i ];
					pMsgContext->resData[ ( dtc_count * 4U ) + 2U ] = DTC_CODE_Array[ 1 ][ u8_i ];
					pMsgContext->resData[ ( dtc_count * 4U ) + 3U ] = DTC_CODE_Array[ 2 ][ u8_i ];
					pMsgContext->resData[ ( dtc_count * 4U ) + 4U ] = uds_u8Eeprom_ReadDTCDataByIdentifier[ u8_i ];

					dtc_count++;
				}
			}

			pMsgContext->resDataLen = 1U + ( dtc_count * 4U );
		}
		else
		{
			DescSetNegResponse ( kDescNrcRequestOutOfRange );
		}
	}
	else
	{
		DescSetNegResponse ( kDescNrcInvalidFormat );
	}
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDtcRSUPDTC (Service request header:$19 $A )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDtcRSUPDTC(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
	uint8_t u8_i = 0U;
	uint16_t dtc_count = 0U;
	uint8_t uds_u8Eeprom_ReadDTCDataByIdentifier[ 32 ];

	for( u8_i = 0U; u8_i< 8U; u8_i++ )
	{
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 0U ] = ( uint8_t )( DTC_BUFFER[ u8_i ] & 0x000000FFU );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 1U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0x0000FF00U ) >> 8U );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 2U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0x00FF0000U ) >> 16U );
		uds_u8Eeprom_ReadDTCDataByIdentifier[ ( 4U * u8_i ) + 3U ] = ( uint8_t )( ( DTC_BUFFER[ u8_i ] & 0xFF000000U ) >> 24U );
	}

	if( pMsgContext->reqDataLen <= 0x02U )
	{
		pMsgContext->resData[ 0 ] = 0x09U; /* DTC Status Availability Mask*/
		for( u8_i = 0U; u8_i < DTC_CODE_NUMBER; u8_i++ )
		{
			pMsgContext->resData[ ( dtc_count * 4U ) + 1U ] = DTC_CODE_Array[ 0 ][ u8_i ];
			pMsgContext->resData[ ( dtc_count * 4U ) + 2U ] = DTC_CODE_Array[ 1 ][ u8_i ];
			pMsgContext->resData[ ( dtc_count * 4U ) + 3U ] = DTC_CODE_Array[ 2 ][ u8_i ];
			pMsgContext->resData[ ( dtc_count * 4U ) + 4U ] = uds_u8Eeprom_ReadDTCDataByIdentifier[u8_i];

			dtc_count++;

			pMsgContext->resDataLen = 1U + ( dtc_count * 4U );
		}
	}
	else
	{
		DescSetNegResponse ( kDescNrcInvalidFormat );
	}
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlDtcSettingEnable (Service request header:$85 $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlDtcSettingEnable(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Contains no response data */
	if( pMsgContext->reqDataLen <= 0x01U )
	{
		pMsgContext->resData[ 0 ] = 0x01;
		pMsgContext->resData = 1U;

		u8_DtcControl = DTC_ENABLE;
	}
	else
	{
		DescSetNegResponse ( kDescNrcInvalidFormat );
	}
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescControlDtcSettingDisable (Service request header:$85 $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlDtcSettingDisable(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Contains no response data */
	if( pMsgContext->reqDataLen <= 0x01U )
	{
		pMsgContext->resData[ 0 ] = OFF;
		pMsgContext->resData = 1U;

		u8_DtcControl = DTC_DISABLE;
	}
	else
	{
		DescSetNegResponse (  kDescNrcInvalidFormat );
	}
  /* User service processing finished. */
  DescProcessingDone();
}


/* ********************************************************************************
 * Function name:ApplDescOnCommunicationDisable
 * Description: Notification function that the communication has been disabled.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescOnCommunicationDisable(void)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* The requested group of messages will no more be sent onto the communication bus. */
}

/* ********************************************************************************
 * Function name:ApplDescOnCommunicationEnable
 * Description: Notification function that the communication has been restored.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescOnCommunicationEnable(void)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* The requested group of messages will be able to be sent onto the communication bus. */
}

/* Check the communication control activity */
/* ********************************************************************************
 * Function name:ApplDescCheckCommCtrl
 * Description:Check if the requested communication manipulation is possible to be performed by the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Diagnostic request handle used only in multi-context system (kDescNumContexts > 1).
 *       - Access type: read
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->txPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Call "DescCommCtrlChecked" (here or later) to confirm the check.
 *   - Call "DescSetNegResponse" to reject the service.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescCheckCommCtrl(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescOemCommControlInfo *commControlInfo)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
  switch(commControlInfo->subNetNumber)
  {
    case kDescCommControlSubNetNumAll:/* Enable/Disable all comm channels (CAN, LIN, etc.)*/
      /* Nothing to do - later the ApplDescSetCommMode will enable/disbale the LIN channels if needed. */
      break;
    case kDescCommControlSubNetNumRx:/* Enable/Disable only the request RX comm channel (CAN)*/
      /* Nothing to do - CANdesc handles the CAN channels */
      break;
    default:
      /* Dispatch subnetworks */
      /* Assumed subnet to CAN mapping: 
       * SubNet 1: LIN 
       * SubNet 2: CAN1 
       * SubNet 3: CAN2 
       */
      switch(commControlInfo->subNetNumber)
      {
        case kDescCommControlSubNetNum01:
          /* LIN network */
          commControlInfo->commCtrlChannel = kDescCommControlCanChNone;
          break;
/* The part is only needed if a multi CAN system is designed !!! */
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
        case kDescCommControlSubNetNum02:
          /* CAN1 */
          commControlInfo->commCtrlChannel = kDescCommControlCanCh01;
          break;
        case kDescCommControlSubNetNum03:
          /* CAN2 */
          commControlInfo->commCtrlChannel = kDescCommControlCanCh02;
          break;
# endif
        default:
          /* Subnet numbers out of range */
          DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcRequestOutOfRange);
          break;
      }
  }
#endif
  /* Confirm the communication status will be accepted. 
   * This can be done later by storing the iContext parameter (if exists) globaly to be able to give the correct acknowledgment.
   */
  DescCommCtrlChecked(DESC_CONTEXT_PARAM_ONLY);
}

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
/* ********************************************************************************
 * Function name:ApplDescSetCommMode
 * Description:Manipulate application specific channels (LIN, MOST, etc.)
 * Returns:  nothing
 * Parameter(s):
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->txPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescSetCommMode(DescOemCommControlInfo *commControlInfo)
{
  switch(commControlInfo->subNetNumber)
  {
    case kDescCommControlSubNetNumAll:/* Enable/Disable all comm channels (CAN, LIN, etc.)*/
      /* !!! Process application specific channels (e.g. LIN) CAN are already enabled/disabled by CANdesc */
      break;
    case kDescCommControlSubNetNumRx:/* Enable/Disable only the request RX comm channel (CAN)*/
      /* Nothing to do - CANdesc handles the CAN channels */
      break;
    default:
      /* Dispatch subnetworks */
      /* Assumed subnet to CAN mapping: 
       * SubNet 1: LIN 
       * SubNet 2: CAN1 
       * SubNet 3: CAN2 
       */
      switch(commControlInfo->subNetNumber)
      {
        case kDescCommControlSubNetNum01:
          /* LIN network */
          /* !!! Process application specific channels (e.g. LIN)*/
          break;
        case kDescCommControlSubNetNum02:          /* CAN1 */
        case kDescCommControlSubNetNum03:          /* CAN2 */
          /* Nothing to do - CANdesc handles all CANs */
          break;
        default:break;
      }
  }
}
#endif

#if defined (DESC_ENABLE_RX_COMM_CONTROL)
/* ********************************************************************************
 * Function name:ApplDescSetCommModeOnRxPath
 * Description: Manipulates only the RX path on CAN. For the other networks (if any) such LIN, MOST, etc. reffer to the
 *              ApplDescSetCommMode API.
 * Returns:  nothing
 * Parameter(s):
 *   - commControlInfo->subNetTxNumber:
 *       - The application shall use this parameter to decied on which physical channels the communiaction will be manipulated.
 *       - Access type: read
 *   - commControlInfo->commCtrlChannel:
 *       - The application determines on which channel the communication will be manipulated (kDescCommControlCanCh01 - kDescCommControlCanCh14).
 *       - Access type: write
 *   - commControlInfo->rxPathState:
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
*   - commControlInfo->rxPathState: - irrelevant for this API since it processes only the RX path!!!
 *       - Activity type: kDescCommControlStateEnable - enables the communication; kDescCommControlStateDisable - disables it.
 *       - Access type: read
 *   - commControlInfo->msgTypes:
 *       - Message group: kDescCommControlMsgAppl - application; kDescCommControlMsgNm - NM; 
 *       - Access type: read
 *   - commControlInfo->reqCommChannel:
 *       - The current CAN channel on which the CommControl request is received.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescSetCommModeOnRxPath(DescOemCommControlInfo *commControlInfo)
{
  if((commControlInfo->rxPathState & kDescCommControlStateEnable) != 0)
  {
    /* _DrvCanSetRxOnlineMode(commControlInfo.commCtrlChannel, g_descCommControlInfo.msgTypes); */
  	if(( commControlInfo->msgTypes & kDescCommControlMsgAppl ) != 0)
		{
			rteCanRxPathDisable = 0U;
		}
  }
  else
  {
    /* _DrvCanSetRxOfflineMode(commControlInfo.commCtrlChannel, g_descCommControlInfo.msgTypes); */
  	if(( commControlInfo->msgTypes & kDescCommControlMsgAppl ) != 0)
		{
			rteCanRxPathDisable = 1U;
		}
  }
}
#endif

/*  ********************************************************************************
 * Function name:ApplDescCheckSessionTransition
 * Description:Check if the given session transition is allowed or your ECU is currently not
 * able to perform it.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - Contains the new state in which the state group will be set.
 *       - Access type: read
 *   - formerState:
 *       - Contains the current state of the state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescSessionTransitionChecked" may be called.
 *   - The function "DescSetNegResponse" may be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescCheckSessionTransition(DescStateGroup newState, DescStateGroup formerState)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
     /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);
  DESC_IGNORE_UNREF_PARAM(formerState);
  /* Just showing how to reject session transition if necessary. 
   * The negative response code may be other depending on the rejection reason.
   * This can be done later, but just store the iContext parameter (if exists) globaly to be able to give the correct acknowledgment. 
   */
  /* DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcConditionsNotCorrect); */
  /* Confirm the session will be accepted. 
   * This can be done later, but just store the iContext parameter (if exists) globaly to be able to give the correct acknowledgment.
   */
  if (newState==kDescStateSessionProgramming)
	{
		CallFblStart();
	}
  else
  {
  	DescSessionTransitionChecked(DESC_CONTEXT_PARAM_ONLY);
  }
;
}


#if defined (DESC_ENABLE_REPORT_ATT_CNTR_STATE)
/* ********************************************************************************
 * Function name:ApplDescSecurityAccessOnAttCntrChanged
 * Description: Once the invalid key attempt counter has been changed, this event is triggered.
 * Returns:  Random value
 * Parameter(s):
 *   - securityLevel:(only available if "level specific failed access attempt supervision" is active)
 *       - Use this information for security level specific handling.
 *       - Access type: read
 *   - chgEv: specifies the reason for hte counter change
 *       - You can use this information in order to perform special activities if needed.
 *       - Access type: read
 *   - newAttCounter: new attempt counter value
 *       - If required, you can store this value into NVM.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" is NOT allowed to be called.
 *   - The function "DescSetNegResponse" is NOT allowed to be called.
 ******************************************************************************** */
void ApplDescSecurityAccessOnAttCntrChanged(DESC_LEVEL_FORMAL_PARAM_DEF_FIRST DescSecAccAttCtrChgEvType chgEv, vuint8 newAttCounter)
{
  switch(chgEv)
  {
    case kDescSecAccAttCtrChgOnTimeExpire:
      /* Event that the penalty time expired - do something if needed */
      break;
    case kDescSecAccAttCtrChgOnTooManyInvalidKeys:
      /* Event that too many invalid keys were received - do something if needed */
    case kDescSecAccAttCtrChgOnInvalidKey: /* fall through */
      /* Event that an invalid key received - do something if needed */
      break;
    case kDescSecAccAttCtrChgOnValidKey:
      /* Event that a valid key is received - do something if needed */
      break;
    case kDescSecAccAttCtrChgOnKeyLengthInvalid:
      /* Event that length of received key is invalid - do something if needed */
      break;
    case kDescSecAccAttCtrChgOnKeyWrongLevel: /* fall through */
      /* Event that key with wrong security access level is received - do something if needed */
      break;
    case kDescSecAccAttCtrChgOnApplRequest:
      /* Event that "DescSetAttemptCounterValue" has changed the counter value.
       * Usually you shall ignore this event type, since it is triggered by the application, but
       * to have complete "OnChange" chain this event will be triggered.*/
      return; /* usually you shall skip updating NVM */
    case kDescSecAccAttCtrChgInvalid:
      /* Invalid event type shall never occur!!! */
    default: /* fall through */
      /* not a valid case - do assert */
      return;/* do not store anything */
  }

  /*
  Optionally you can still access the current (not yet changed) value of the counter */
  if ( (DescGetAttemptCounterValue(DESC_LEVEL_CONTEXT_PARAM_VALUE_SET) == 0) &&
       (newAttCounter == 1) )
  {
    /* do something on very first increment of the counter */
  }


  /* Update the attempt counter in the NVM in all cases
  eepWrite(secAccessAttCntrHndl, newAttCounter);
  */
}
#endif

/******************************************************************************
* Name         :  SecM_ComputeKey  
* Called by    :  CheckKey
* Preconditions:  None
* Parameters   :  None
* Description  :  
******************************************************************************/
static vuint32 SecM_ComputeKey(void)
{
  vuint32 tmpX, tmpY;

  tmpX=( ( ( g_applDescSeedX ^ 0xA5A5C3C3 ) * 1859775393 ) % 4294967296 + 2840853838 ) % 4294967296;
  tmpY=( ( ( g_applDescSeedY ^ 0xA5A5C3C3 ) * 1518500249 ) % 4294967296 + 2400959708 ) % 4294967296;
  return (vuint32)(tmpX ^ tmpY);
}

/******************************************************************************
* Name         :  SecM_Serializer  
* Called by    :  CheckKey
* Preconditions:  None
* Parameters   :  None
* Description  :  
******************************************************************************/
static void SecM_Serializer(DescMsg tgtPtr, vuint32 data)
{
  vuint8_least iter;
  iter = 4;
  while(iter != 0)
  {
    iter--;
    tgtPtr[iter] = (DescMsgItem)data;
    data >>= 8;
  }
}

/* ********************************************************************************
 * Function name:ApplDescSecurityAccessGetSeed
 * Description: Each time called must generate a different value (e.g. current free running timer value).
 * Returns:  Random value
 * Parameter(s):
 *   - iContext:(not available in single context systems)
 *       - Use this call-back handle for all API which need it.
 *       - Access type: read
 *   - securityLevel:
 *       - The current security level represented by the generated contsants (e.g kDescStateSecurityAccessLevel1e etc.).
 *       - Access type: read
 *   - seed:
 *       - A pointer where the generated seed must be written by the application.
 *       - Access type: write
 *   - seedLen:
 *       - The length of the written seed.
 *       - Access type: write
 *   - securityAccessDataRecordLength (only if securityAccessData is supported)
 *       - The length of security access data record.
 *       - Access type: read
 *   - dataPtrSecurityAccessData (only if securityAccessData is supported)
 *       - A pointer to security access data record.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" is NOT allowed to be called.
 *   - The function "DescSetNegResponse" may be called.
 ******************************************************************************** */
void ApplDescSecurityAccessGetSeed(DescSecurityAccessContext* pDescSecurityAccessContext)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/

  /* Generate each time a random 64Bit value !!! 
   * Example:
   */
	uint8_t u8s_SeedX[ 4 ]={0U,0U,0U,0U};
	uint8_t u8s_SeedY[ 4 ]={0U,0U,0U,0U};

	srand( Get_PIT_CH3_CVAL() );

	u8s_SeedX[ 0 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );
	u8s_SeedX[ 1 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );
	u8s_SeedX[ 2 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );
	u8s_SeedX[ 3 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );

	u8s_SeedY[ 0 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );
	u8s_SeedY[ 1 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );
	u8s_SeedY[ 2 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );
	u8s_SeedY[ 3 ] = ( uint8_t )( ( ( uint8_t )rand() % 255U ) + 1U );

  g_applDescSeedX = DescMake32Bit(u8s_SeedX[ 0 ], u8s_SeedX[ 1 ], u8s_SeedX[ 2 ], u8s_SeedX[ 3 ]);
  g_applDescSeedY = DescMake32Bit(u8s_SeedY[ 0 ], u8s_SeedY[ 1 ], u8s_SeedY[ 2 ], u8s_SeedY[ 3 ]);

  /* MSB 32Bit*/
  SecM_Serializer(&(pDescSecurityAccessContext->dataPtr[0]), g_applDescSeedX);
  /* LSB 32Bit*/
  SecM_Serializer(&(pDescSecurityAccessContext->dataPtr[4]), g_applDescSeedY);

  /* Currently the example will calculate always a 8 Byte SEED */
  /* dataLen parameter is already initialized with the seed length from the CDD file */
  /* pDescSecurityAccessContext->dataLen = 8;*/

  /* Call this function to confirm the process end now or outside of this call-back */
  DescSecurityAccessSeedReady(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pDescSecurityAccessContext->iContext));
}

/* ********************************************************************************
 * Function name:ApplDescSecurityAccessCheckKey
 * Description: The application must validate the received security key.
 * Returns:  Random value
 * Parameter(s):
 *   - iContext:(not available in single context systems)
 *       - Use this call-back handle for all API which need it.
 *       - Access type: read
 *   - securityLevel:
 *       - The current security level represented by the generated contsants (e.g kDescStateSecurityAccessLevel1e etc.).
 *       - Access type: read
 *   - key:
 *       - A pointer where the received key must be read from by the application.
 *       - Access type: read
 *   - keyLength:
 *       - The length of the received key.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" is NOT allowed be called.
 *   - The function "DescSetNegResponse" may be called.
 ******************************************************************************** */
void ApplDescSecurityAccessCheckKey(DescSecurityAccessContext* pDescSecurityAccessContext)
{
   /* The size of this array may vary and depends on the security key definition in the CDD file. */
  vuint32 tmpKey;     /* Store Key on the stack, invisible for extern access */

  /* Key is OK */
  pDescSecurityAccessContext->status = kDescSaStatusOk;

  /* Calculate the Key */
  tmpKey = SecM_ComputeKey();

  /* Compare results with Key from tester */
  if (tmpKey != DescMake32Bit(pDescSecurityAccessContext->dataPtr[0],
                              pDescSecurityAccessContext->dataPtr[1],
                              pDescSecurityAccessContext->dataPtr[2],
                              pDescSecurityAccessContext->dataPtr[3])
      )
  {
    /* Key is INVALID */
    pDescSecurityAccessContext->status = kDescSaStatusNok;
  }
  /* Call this function to confirm the process end now or outside of this call-back */
  DescSecurityAccessKeyChecked(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pDescSecurityAccessContext->iContext));
}

/*  ********************************************************************************
 * Function name:ApplDescReadDidECU_Status_Message (Service request header:$22 $EF $1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidECU_Status_Message(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
	const AdcRealValuesType* ldcAdcRealValues = RTE_GET_ADC_REAL_RESULT();

	uint8_t u8_SupplyVoltLevel = ( uint8_t )ldcAdcRealValues->realBatteryVoltage;

	pMsgContext->resData[0] = DescGetHiByte( CMX_VER );
  pMsgContext->resData[1] = DescGetLoByte( CMX_VER );
  pMsgContext->resData[2] = u8_SupplyVoltLevel;
  pMsgContext->resData[3] = CanTxActualErrorCounter ();
  pMsgContext->resData[4] = CanRxActualErrorCounter ();
  pMsgContext->resData[5] = rteCanBusOffCnt;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 6;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidSYMC_Part_Number (Service request header:$22 $F1 $87 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidSYMC_Part_Number(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = 0x31; /* 1 */
  pMsgContext->resData[1] = 0x30; /* 0 */
  pMsgContext->resData[2] = 0x37; /* 7 */
  pMsgContext->resData[3] = 0x31; /* 1 */
  pMsgContext->resData[4] = 0x30; /* 0 */
  pMsgContext->resData[5] = 0x33; /* 3 */
  pMsgContext->resData[6] = 0x39; /* 9 */
  pMsgContext->resData[7] = 0x30; /* 0 */
  pMsgContext->resData[8] = 0x30; /* 0 */
  pMsgContext->resData[9] = 0x30; /* 0 */
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 10;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidSYMC_Software_version (Service request header:$22 $F1 $89 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidSYMC_Software_version(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = ( uint8_t )SW_VER_HIGH;
  pMsgContext->resData[1] = ( uint8_t )SW_VER_LOW;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 2;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidSystem_supplier (Service request header:$22 $F1 $8A )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidSystem_supplier(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = 0x45; /* E */
  pMsgContext->resData[1] = 0x44; /* D */
  pMsgContext->resData[2] = 0x33; /* 3 */
  pMsgContext->resData[3] = 0x30; /* 0 */
  pMsgContext->resData[4] = 0x37; /* 7 */
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 5;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidRepair_Shop_Code_or_Tester_Serial_Number (Service request header:$22 $F1 $98 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidRepair_Shop_Code_or_Tester_Serial_Number(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = *( ( volatile uint8_t * )0x00806000U );
  pMsgContext->resData[1] = *( ( volatile uint8_t * )0x00806001U );
  pMsgContext->resData[2] = *( ( volatile uint8_t * )0x00806002U );
  pMsgContext->resData[3] = *( ( volatile uint8_t * )0x00806003U );
  pMsgContext->resData[4] = *( ( volatile uint8_t * )0x00806004U );
  pMsgContext->resData[5] = *( ( volatile uint8_t * )0x00806005U );
  pMsgContext->resData[6] = *( ( volatile uint8_t * )0x00806006U );
  pMsgContext->resData[7] = *( ( volatile uint8_t * )0x00806007U );
    /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 8;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidProgramming_Date (Service request header:$22 $F1 $99 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidProgramming_Date(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = *( ( volatile uint8_t * )0x00806008U );
  pMsgContext->resData[1] = *( ( volatile uint8_t * )0x00806009U );
  pMsgContext->resData[2] = *( ( volatile uint8_t * )0x0080600AU );
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 3;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidDiagnostic_Information (Service request header:$22 $F1 $A0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidDiagnostic_Information(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = 0x01;
  pMsgContext->resData[1] = 0x01;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 2;
  /* User service processing finished. */
  DescProcessingDone();
}


/*  ********************************************************************************
 * Function name:ApplDescReadDidProgramming_Identification_Information (Service request header:$22 $F1 $A1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadDidProgramming_Identification_Information(DescMsgContext* pMsgContext)
{
  /* <<TBD>> Remove this comment once you have completely implemented this function!!! */
  /* Contains no request data */
  /* Dummy example of how to write the response data. */
  pMsgContext->resData[0] = 0x10;
  pMsgContext->resData[1] = 0x00;
  pMsgContext->resData[2] = 0x42;
  pMsgContext->resData[3] = 0x00;
  pMsgContext->resData[4] = 0x02;
  pMsgContext->resData[5] = 0xFF;
  pMsgContext->resData[6] = 0xFF;
  pMsgContext->resData[7] = 0x00;
  pMsgContext->resData[8] = 0x00;
  pMsgContext->resData[9] = 0xFF;
  pMsgContext->resData[10] = 0xFF;
  pMsgContext->resData[11] = 0x00;
  pMsgContext->resData[12] = 0x00;
  pMsgContext->resData[13] = 0x00;
  /* Always set the correct length of the response data. */
  pMsgContext->resDataLen = 14;
  /* User service processing finished. */
  DescProcessingDone();
}


#if defined (DESC_ENABLE_MULTI_CFG_SUPPORT)
/* ********************************************************************************
 * Function name:ApplDescIsDataIdSupported
 * Description: Additionaly reject a supported PID (multi ECU configuration)
 * Returns:  kDescTrue - if still supported, kDescFalse - if not supported
 * Parameter(s):The PID number
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
DescBool ApplDescIsDataIdSupported(vuint16 pid)
{
  return kDescTrue;
}
#endif



